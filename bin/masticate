#!/usr/bin/env ruby

require_relative "../lib/masticate"
require "optparse"

command = ARGV.shift

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: example.rb [options]"

  opts.on("--format FORMAT", "Specify format") do |v|
    options[:format] = v
  end

  opts.on("--delim DELIMITER", "Specify field delimiter (character or TAB)") do |v|
    options[:col_sep] = v
    options[:col_sep] = "\t" if options[:col_sep] == "TAB"
  end

  opts.on("--fields LIST", Array, "Specify fields to select") do |list|
    options[:fields] = list
  end

  opts.on("--field FIELD", "Specify field to convert") do |f|
    options[:field] = f
  end

  opts.on("--snip DIRECTIVE", "Specify header fields to snip: first N, or by name") do |f|
    options[:snip] = f.to_i
  end

  opts.on("--from REGEXP", "Regular expression for gsub conversion") do |s|
    options[:from] = s
  end

  opts.on("--to STRING", "Result string for gsub conversion") do |s|
    options[:to] = s
  end

  opts.on("--inlined", "(for *mend* only) Source file has headers inlined on each line") do |v|
    options[:inlined] = v
  end
end.parse!

filename = ARGV.shift # use stdin if no filename provided

def logmessage(command, options, results)
  $stderr.puts <<-EOT
* masticate #{command} (#{options.keys.join(', ')})
  Lines in input: #{results[:input_count]}
  Lines in output: #{results[:output_count]}
EOT
end

case command
when 'sniff'
  results = Masticate.sniff(filename)
  col_sep = results[:col_sep]
  col_sep = "TAB" if col_sep == "\t"
  quote_char = results[:quote_char] || "NONE"
  $stderr.puts <<-EOT
Processing complete.
  Input delimiter: #{col_sep}
  Quote char: #{quote_char}
  Field counts: #{results[:field_counts].inspect}
  Headers: #{results[:headers].join(',')}
EOT

when 'mend'
  results = Masticate.mend(filename, options)
  logmessage(command, options, results)

when 'csvify'
  results = Masticate.csvify(filename, options)
  logmessage(command, options, results)

when 'pluck'
  results = Masticate.pluck(filename, options)
  logmessage(command, options, results)

when 'datify'
  results = Masticate.datify(filename, options)
  logmessage(command, options, results)

when 'gsub'
  results = Masticate.gsub(filename, options)
#   $stderr.puts <<-EOT
# Processing complete.
#   Lines in input: #{results[:input_count]}
#   Lines in output: #{results[:output_count]}
# EOT

else
  raise "unknown command #{command}"
end
